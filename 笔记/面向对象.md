# 面向对象

## 操作符

* instanceof

    用于判断是否该构造函数的实例

    ``` javascript
        person1 instanceof Person
    ```


## 创建对象

1. 工厂模式

    ``` javascript
    function createPeople(name, age, job) {
        var o = new Object(); //var o = {};
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayName = function() {
            alert(this.name)
        }
        return o;
    }
    var people1 = createPeople("nicholas", 29, "software engineer");
    var people2 = createPeople("greg", 23, "doctor");
    ```

    工厂模式虽然解决创建多个相似对象的问题，但是没有解决对象识别的问题，即怎么知道一个对象的类型（引用类型）

2. 构造函数模式

    ``` javascript
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function() {
            alert(this.name);
        } //等价于 this.sayName = new Function("alert(this.name)");
    }
    var person1 = new Person("nicholas2", 39, "old software engineer");
    var person2 = new Person("greg2", 33, "old doctor");
    ```

    构造函数与工厂模式区别：
    1. 构造函数里面没有创建对象；
    2. 构造函数直接将属性和方法赋给this对象；
    3. 构造函数里面没有return语句。
    4. 构造函数首字母大写(约定俗成，构造函数始终都以大写字母开头，非构造函数以小字母开头)，创建新实例，必须用到new操作符。

    用new创建一个新实例，实际经历以下四个过程：
    1. 创建一个新对象；
    2. 将构造函数作用域赋给新对象(所以this就指向这个新对象)；
    3. 执行构造函数中代码(为新对象添加属性)；
    4. 返回新对象(相当于返回this)。

    构造函数缺点： *不同实例上的同名函数是不相等的*。

3. 原型

    我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象（原型对象），而这个对象的用途是包含可以有特定类型的所有实例共享的属性和方法。

    在默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性。

    ``` javascript
    function Person() {
    }
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function() {
        console.log(this.name);
    }
    var person1 = new Person();
    ```

    概念：
    * function Person() -- 构造函数
    * Person.prototype -- 构造函数指向原型对象的指针（其实在js里面任何引用类型值都是指针，都不是实际的值，实际的值在内存中）
    * person1 -- 实例
    * person1的[[Prototype]] -- 实例指向原型对象的指针(不可以直接访问)
    * Person Prototype -- (Person及Person实例)的原型对象（存在于内存中，不可以直接操作）
    * 原型对象上的constructor属性 或者 Person.prototype.constructor -- 指向回构造函数(Person)
    * person1.的constructor属性 -- 即系Person.prototype.constructor

        为什么实例上明明没有constructor属性，但是却读取到constructor属性。

        因为解析器读取实例属性的时候，先读取实例的属性，如果实例自身没有；则在实例的原型那里寻找。

        实例(person1)的constructor属性 就是 构造函数(Person)的原型对象(Person Prototype)的constructor属性（实例属性没constructor的时候，因为实例没有所以在原型上寻找) 指向构造函数(Person)本身

    第二种原型写法，重写原型

    ``` javascript
    Person.prototype = {
        constructor:Person,
        name: "Nicholas",
        age: 29,
        job: "Software Engineer",
        sayName: function() {
            console.log(this.name);
        }
    }
    ```

    这种写法有以下特点:
    1. 写法更加简单
    2. 一定要重定向，就是一定要设置constructor属性（因为constructor本来是自动获取的，重写原型后，会确实constructor，所以要重新设置）。但是这样会导致constructor可枚举
    3. 重写后，原型指向新的对象。但是重写后创建的实例原型才是指向新的原型，重写前创建的对象还是指向原来的原型。这里值得注意，否则好容易出错。特别是在构造函数里面修改原型的话，不要使用重写原型的方式，因为用new调用构造函数的时候，已经创建了实例，然后再运行构造函数里面的重写原型语句，就是这个实例就会没有新原型里面的属性方法。

#### 创建对象的各种模式

1. 工厂模式
2. 组合使用构造函数模式和原型模式(最常用)

    ``` javascript
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.friend = ["Shelbey", "Court"];
        this.sayHi = function() {
            alert(hi);
        }
    }
    Person.prototype = {
        constructor: Person,
        teacher: ["Mr Wang"],
        sayName: function() {
            alert(this.name);
        }
    }
    var person1 = new Person("Nicholas", 29, "Software Engineer");
    ```

    如果一个属性是全部实例共用的（一般是方法），就写在原型中；如果这个属性是每个实例独特（即使值的相同的，但是不是指向同一个内存位置），就写在构造函数中

3. 动态原型模型

    ``` javascript
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        if(!this.sayName) { // 判断一个就可以了，保证有将属性方法添加到原型上即可。
            Person.prototype.sayName = function() { //这里不能使用字面量重写，不然第一个实例会没有sayName这个方法
                alert(this.name);
            }
            Person.prototype.sayHi = function() { 
                alert("hi");
            }
        }
    }
    var person1 = new Person("Nicholas", 29, "Software Engineer");
    ```

    就是将所有信息都封装在够着函数里面，但是又保持使用构造函数和原型的优点。
