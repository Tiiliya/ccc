# 面向对象

## 操作符 

* instanceof

    用于判断是否该构造函数的实例

    ``` javascript
        person1 instanceof Person
    ```


## 创建对象

1. 工厂模式

    ``` javascript
    function createPeople(name, age, job) {
        var o = new Object(); //var o = {};
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayName = function() {
            alert(this.name)
        }
        return o;
    }
    var people1 = createPeople("nicholas", 29, "software engineer");
    var people2 = createPeople("greg", 23, "doctor");
    ```

    工厂模式虽然解决创建多个相似对象的问题，但是没有解决对象识别的问题，即怎么知道一个对象的类型（引用类型）

2. 构造函数模式
    
    ``` javascript
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function() {
            alert(this.name);
        } //等价于 this.sayName = new Function("alert(this.name)");
    }
    var person1 = new Person("nicholas2", 39, "old software engineer");
    var person2 = new Person("greg2", 33, "old doctor");
    ```

    构造函数与工厂模式区别：
    1、构造函数里面没有创建对象；
    2、构造函数直接将属性和方法赋给this对象；
    3、构造函数里面没有return语句。
    4、构造函数首字母大写(约定俗成，构造函数始终都以大写字母开头，非构造函数以小字母开头)，创建新实例，必须用到new操作符。

    用new创建一个新实例，实际经历以下四个过程：
    1、创建一个新对象；
    2、将构造函数作用域赋给新对象(所以this就指向这个新对象)；
    3、执行构造函数中代码(为新对象添加属性)；
    4、返回新对象(相当于返回this)。

    *构造函数缺点：* 不同实例上的同名函数是不相等的。

3. 原型
    
    我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象（原型对象），而这个对象的用途是包含可以有特定类型的所有实例共享的属性和方法。

    在默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性。

    ``` javascript
    function Person() {
    }
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function() {
        console.log(this.name);
    }
    ```
